#!/usr/bin/env python

from __future__ import print_function

import string
import SocketServer
import sys
import re

proxy_lport = 27017 # What port do we listen on?
proxycfg = "file:mongoe.cfg" # Right now this is the only cfg method

class MyTCPHandler(SocketServer.StreamRequestHandler):
	def process_request(self):
		cleaner("hi")
		pass
	def handle(self):
		self.process_request()
#########
# mongoe
#
# Author: Pat Gunn <pgunn@dachte.org>
# Apache License

def cleaner(toclean):
	# Wire protocol details include binary data but are still potentially
	# interesting to log. This cleans them up for display
	pass

###############
# Router
def setup_proxy(cfgspec):
	# Read the proxy config string, setup the global proxy state
	# returns associative array for what schema maps to where
	(mode, args) = string.split(cfgspec, ':', 2)
	if(mode == 'file'):
		ret = load_proxyinfo_from_file(args)
	else:
		print("Unsupported proxy method [" + mode + "\n", file=sys.stderr)
		sys.exit(1)
	return ret

def load_proxyinfo_from_file(fn):
	# Load a colon-separated file that maps:
	# SCHEMA:HOST:PORT
	fh = open(fn, 'rb')
	for line in fh:
		line = re.sub('[\n\r\f]', '', line) # Remove newlines and stuff
		line = re.sub('#.*', '', line) # Strip comments
		line = re.sub('^\s+', '', line)
		line = re.sub('\s+$', '', line)
		if(re.match('^$', line)):
			continue # Skip blank lines
		(schema, host, port) = string.split(line, ':', 3)
		ret = {}
		ret[schema] = {}
		ret[schema]['host'] = host
		ret[schema]['port'] = port
	fh.close()
	if '_DEFAULT' not in ret:
		print("You must define a _DEFAULT schema\n")
		sys.exit(1)
	return ret

def route_for_destination(schema):
	# Given a schema, return the (host,port) pair it maps to
	if not schema in proxy:
		schema = "_DEFAULT" # We should always have entries for this
	host = proxy[schema]['host']
	port = proxt[schema]['port']
	return host, port

def get_router_iterable():
	# Packages the entire routing config up into a single data structure
	# for something to walk it efficiently by endpoint rather than by schema served.
	# returns a 2-key a-a with ip and port as the 2 keys, and the value
	# being a reference to a list of the schemas served by the endpoint.
	ret = ()
	schemot = proxy.keys()
	for schema in schemot:
		host = proxy[schema]['host']
		port = proxy[schema]['port']
		if not host in ret:
			ret[host] = {}
		if not port in ret[host]:
			ret[host][port] = ()
		ret[host][port].append(schema)
	return ret

###############
# Wire Protocol and BSON stuff

def bson_document_to_docarray(data, numdocs=0):
	# Given BSON data that can contain multiple documents, and an optional specifier
	# of how many docs should be in there, return an array of those docs.
	pass
def info_message(msg):
	# Return a string describing in detail the message passed in
	pass
def parse_reply(resp):
	# Parse reply sent by a backend server
	pass
def read_message(fh):
	pass
def parse_op(opcode, request, opinfo):
	# Pass in: (non-decoded) opcode, request
	# Returns: opname, schema, table
	pass

def command_admin(req):
	# True if this is a request to the admin schema, else False
	if 'schema' in req and req[schema] == 'admin':
		return 1
	return 0

def extract_admin_cmd(req):
	pass

def extract_schema_info_from_response(req):
	# Return an a-a with schema names as key, value is something
	# extract_schema_info_from_response() can use
	pass

def build_filtered_schemalist(listreq, pool):
	# Reach out to backend databases, build data structure with info on schemas
	# that exist on them that we can reach w/ our current config, suitable for building
	# a response to the listDatabases command
	pass

def cmd_forbidden(cmd):
	forbidden = 	{
			'shutdown'		:1,
			'replSetGetStatus'	:1,
			'replSetFreeze'		:1,
			'replSetInitiate'	:1,
			'replSetMaintenance'	:1,
			'replSetReconfig'	:1,
			'replSetStepDown'	:1,
			'replSetSyncFrom'	:1,
			'resync'		:1,
			'replSetGetConfig'	:1,
			'flushRouterConfig'	:1,
			'addShard'		:1,
			'cleanupOrphaned'	:1,
			'checkShardingIndex'	:1,
			'enableSharding'	:1,
			'listShards'		:1,
			'removeShard'		:1,
			'getShardMap'		:1,
			'getShardVersion'	:1,
			'mergeChunks'		:1,
			'setShardVersion'	:1,
			'shardCollection'	:1,
			'shardingState'		:1,
			'unsetSharding'		:1,
			'split'			:1,
			'splitChunk'		:1,
			'splitVector'		:1,
			'medianKey'		:1,
			'moveChunk'		:1,
			'movePrimary'		:1,
			'isdbgrid'		:1,
			'logRotate'		:1
			}
	if cmd in forbidden:
		return 1
	return 0


##############
# Speak BSON

def bson_i_refuse(reqid):
	# Generate an OP_REPLY with a payload amounting to refusing an operation
	pass

def bson_response_listDatabases(reqid,dbinfo):
	# Generrate an OP_REPLY with a payload that's a valid response to listDatabases
	pass

def schinfo_totalsize(schemot):
	size = 0
	for schema in schemot.keys():
		size += schemot[schema]['sizeOnDisk']
	return size

##############
# Poor man's connection pool

def ensure_mongo_connection(pool, host, port):
	# Make sure there's a connection to this server
	# Return that connection.
	pass

if __name__ == "__main__":
	global proxy
	proxy = setup_proxy(proxycfg)
	server = SocketServer.TCPServer(('localhost', proxy_lport), MyTCPHandler)
	server.serve_forever()


