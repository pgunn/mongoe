#!/usr/bin/perl -w

use strict;
use BSON;
use warnings FATAL => qw(all);
use 5.10.0;

my $proxy_lport = 27017; # What port do we listen on?
my $proxycfg = "file:mongoe.cfg"; # Right now this is the only cfg method

##
# Plumbing for the 1.x (not 0.x!) version of the Mongo Perl bindings
use lib '.'; # Only needed if you've unpacked the Perl mongo driver as a subdir of here
use MongoDB::_Protocol;
use MongoDB::_Link;
use MongoDB::Error;
##

my $proxy; # Holds global proxy state

##
# Plumbing for Net::Server, which manages connections
# so I just write a handler for incoming clients
package MongoProxy;
use base qw(Net::Server);
#

main();

###################
# mongoe
#
# Calls private methods of the Perl Mongo driver (1.x)
# Sorry about that
#
# Author: Pat Gunn <pgunn@dachte.org>
# Copyright MongoDB 2015
# Apache License

sub process_request
{	# When you use Net::Server, you provide an entry point for
	# handling incoming connections, and it spawns a thread per
	# client, beginning execution at that entry point with STDIN/STDOUT
	# mapped to the network socket. This is that entry point for
	# mongoe
	#
	# http://docs.mongodb.org/meta-driver/latest/legacy/mongodb-wire-protocol/
	# Documents the formatting of the messages being passed back and forth.
	# If you modify this, be meticulous with reading that so you don't create
	# deadlocks

my ($self) = @_;
my $client = *STDIN;
binmode $client;
binmode STDOUT;
my $pool;
while(! eof($client))
	{
	# Read the 4 int32 fields that are the MsgHeader
	my $request;
	$request = ""; # Empty. Not sure if this can happen.
	my %req = read_message($client);
	print STDERR info_message(%req);
	my $conn = ensure_mongo_connection($pool, route_for_destination($req{schema}));
	$conn->write($req{raw});
	if(! $conn->remote_connected() )
		{print STDERR "Warning: mongod for $req{schema} has disconnected\n";}
	my $resp = $conn->read(); # TODO I need to add a handler for NetworkError events.
	print $resp;
	}
}

sub cleaner($)
{	# Wire protocol details include binary data but are still potentially
	# interesting to log. This cleans them up for display
my ($toclean) = @_;
$toclean =~ s/[^[:ascii:]]/\?/g;
$toclean =~ tr/\n\f\r/\?/d;
return $toclean;
}

##################
# Router

sub setup_proxy($)
{	# Read the proxy config string, setup the global proxy state
	# (hashref) for what schema maps to where
my ($cfg) = @_;
my %ret;

my ($mode, $args) = split(':', $cfg, 2);
if($mode eq 'file')
	{%ret = load_proxyinfo_from_file($args);}
else	{die "Unsupported proxy method [$mode]\n";}

return \%ret;
}

sub load_proxyinfo_from_file($)
{	# Load a colon-separated file that maps:
	# SCHEMA:HOST:PORT
my ($fn) = @_;
my %ret;
open(my $fh, $fn) || die "Could not open proxy descriptor file [$fn]:$!\n";
while(<$fh>)
	{
	tr/\n\r\f//d; # Remove newlines and stuff
	s/#.*//; # Strip comments
	s/^\s+//;
	s/\s+$//;
	next if(/^$/); # Skip blank lines
	my($schema, $host, $port) = split(':', $_);
	$ret{$schema}{host} = $host;
	$ret{$schema}{port} = $port;
	#print "Learned schema [$schema]\n";
	}
close($fh);
if(! defined($ret{_DEFAULT}))
	{die "You must define a _DEFAULT schema\n";}

return %ret;
}

sub route_for_destination($)
{	# Given a schema, return the (host,port) pair it maps to
my ($schema) = @_;

my ($host, $port); # Return this
if(! defined($$proxy{$schema}))
	{$schema = "_DEFAULT";} # We should always have entries for this

$host = $$proxy{$schema}{host};
$port = $$proxy{$schema}{port};
return ($host, $port);
}

##################
# Wire Protocol and BSON stuff

sub info_message(%)
{	# TODO When we can decode BSON better, we can make this much, much nicer.
	#	We may eventually pull all this stuff into an object interface, which
	#	would make the code cleaner too.
my %msg = @_;
my $ret = '';
$ret .= "Message(" . $msg{msglen_decoded} . "): " . $msg{opname} . "(" . $msg{opcode_decoded} . ")\n";
$ret .= "\tSchema: " . (defined($msg{schema}) ? $msg{schema} : 'UNKNOWN') . "\n";
$ret .= "\tTable: " . (defined($msg{table}) ? $msg{table} : 'UNKNOWN') . "\n";
$ret .= "\t[" . cleaner($msg{raw}) . "]\n";
return $ret;
}

sub read_message($)
{
my ($fh) = @_;

my %ret;
read($fh, $ret{msglen}, 4); # Size of messages in bytes, including header!
read($fh, $ret{reqid} , 4);
read($fh, $ret{respto}, 4);
read($fh, $ret{opcode}, 4);
$ret{raw} = join('', @ret{"msglen", "reqid", "respto", "opcode"});
$ret{msglen_decoded} = unpack('l', $ret{msglen});
$ret{opcode_decoded} = unpack('l', $ret{opcode});
my $content;

if($ret{msglen_decoded} > 16)
	{read($fh, $content, ($ret{msglen_decoded} - 16));}

parse_op($ret{opcode}, $content, \%ret);

$ret{raw} .= $content;
return %ret;
}

sub parse_op($$$)
{	# Pass in: (non-decoded) opcode, request
	# Passes back: opname, schema, table
my ($opcode, $request, $opinfo) = @_;

my $opcode_d = unpack('l', $opcode);
if($opcode_d == 2001) # OP_UPDATE
	{
	my (undef, $coll) = unpack("lZ*", $request);
	my ($schema, $table) = split(/\./, $coll);
	@$opinfo{'opname','schema','table'} = ('OP_UPDATE', $schema, $table);
	}
elsif($opcode_d == 2002) # OP_INSERT
	{
	my (undef, $coll) = unpack("lZ*", $request);
	my ($schema, $table) = split(/\./, $coll);
	@$opinfo{'opname','schema','table'} = ('OP_INSERT', $schema, $table);
	}
elsif($opcode_d == 2004) # OP_QUERY
	{
	my (undef, $coll, undef, undef, $doclen) = unpack("lZ*lll", $request, ''); # Flags, collection, skip, return, the rest
	my ($schema, $table) = split(/\./, $coll);
	my $qdoc2 = $request;
	$qdoc2 =~ s/[^A-Za-z]/_/g;
	print STDERR "BSON parse [$qdoc2] of stated length $doclen string length " . length($request) . "\n";
	print STDERR decode_bson($doclen . $request);
	@$opinfo{'opname','schema','table'} = ('OP_QUERY', $schema, $table, ));
	}
elsif($opcode_d == 2005) # OP_GET_MORE
	{
	my (undef, $coll) = unpack("lZ*", $request);
	my ($schema, $table) = split(/\./, $coll);
	@$opinfo{'opname','schema','table'} = ('OP_GET_MORE', $schema, $table);
	}
elsif($opcode_d == 2006) # OP_DELETE
	{
	my (undef, $coll) = unpack("lZ*", $request);
	my ($schema, $table) = split(/\./, $coll);
	@$opinfo{'opname','schema','table'} = ('OP_DELETE', $schema, $table);
	}
elsif($opcode_d == 2007) # OP_KILL_CURSORS
	{
	@$opinfo{'opname','schema','table'} = ('OP_KILL_CURSORS', undef, undef);
	}
else
	{
	@$opinfo{'opname','schema','table'} = ('OP_UNKNOWN', undef, undef);
	}
}

##################
# Poor man's connection pool

sub ensure_mongo_connection
{	# Make sure there's a connection to this server.
	# Return that connection.
my ($pool, $host, $port) = @_;

if(! defined($$pool{"$host$port"})) # TODO OR if the connection is no longer up....
	{
	my $conn = MongoDB::_Link->new("$host:$port");
	$conn->connect();
	$$pool{"$host$port"} = $conn;
	}
return $$pool{"$host$port"};
}


##################
sub main
{	# When you use Net::Server, your main function is primarily
	# to prepare you to enter the event loop the module provides
$proxy = setup_proxy($proxycfg);
MongoProxy->run(port => $proxy_lport);
}

